---
title: "MSTR-BTC Pairs Trading Strategy"
author: "Jack Li, Bill Wang, Paul Zhao"
date: "April 25, 2025"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
---

```{=html}
<!-- GitHub Button with improved positioning to avoid overlap with search button -->
<style>
/* Styles for GitHub button to be placed in the Quarto navbar */
.navbar-github-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 4px;
  border-radius: 4px;
  transition: background-color 0.2s;
  margin-right: 15px; /* Add more margin to avoid overlap */
}

.navbar-github-button:hover {
  background-color: rgba(0, 0, 0, 0.1);
}

.navbar-github-button svg {
  width: 24px;
  height: 24px;
  fill: currentColor;
}

/* Move the search button to the left a bit */
.quarto-search {
  margin-right: 50px !important; /* Add important to override default styles */
}
</style>

<!-- Script to inject the GitHub button into the navbar after page loads -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  // Create GitHub button element
  var githubButton = document.createElement('a');
  githubButton.className = 'navbar-github-button';
  githubButton.href = 'https://github.com/Aspros-paul/QFDteam_533';
  githubButton.target = '_blank';
  githubButton.setAttribute('aria-label', 'View on GitHub');
  githubButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/></svg>';

  // Function to handle navbar insertion with better positioning
  function insertGitHubButton() {
    // First, try to find the search button
    var searchButton = document.querySelector('.quarto-search');

    if (searchButton) {
      // Move the search button to the left
      searchButton.style.marginRight = '50px';

      // Insert our GitHub button after the search button
      searchButton.parentNode.insertBefore(githubButton, searchButton.nextSibling);
    } else {
      // If search button isn't found, try the right navbar section
      var navbarRight = document.querySelector('.navbar-nav.navbar-nav-scroll.ms-auto');
      if (navbarRight) {
        // Create a list item for the button
        var listItem = document.createElement('li');
        listItem.className = 'nav-item';
        listItem.appendChild(githubButton);

        // Insert at the end of the right navbar
        navbarRight.appendChild(listItem);
      } else {
        // Final fallback - if we can't find the right navbar section, append to the navbar container
        var navbar = document.querySelector('.navbar-container');
        if (navbar) {
          navbar.appendChild(githubButton);
        }
      }
    }
  }

  // Try inserting immediately
  insertGitHubButton();

  // Also try after a slight delay to ensure all Quarto elements are fully rendered
  setTimeout(insertGitHubButton, 500);
});
</script>
```

```{python}
#| echo: false
#| warning: false
#| message: false

# Load necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import statsmodels.api as sm
from statsmodels.regression.linear_model import OLS
from statsmodels.tsa.stattools import adfuller
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import datetime

# Load real data from CSV
data = pd.read_csv('data/mstr_btc_data_2Y_daily.csv', index_col=0, parse_dates=True)

# Calculate returns
returns = data.pct_change().dropna()

# Calculate ratio and Z-score
data['Ratio'] = data['MSTR'] / data['BTC']
data['Ratio_MA'] = data['Ratio'].rolling(window=20).mean()
data['Ratio_STD'] = data['Ratio'].rolling(window=20).std()
data['Z_Score'] = (data['Ratio'] - data['Ratio_MA']) / data['Ratio_STD']

# Drop NaN values after calculations
data = data.dropna()

# Run regression analysis for beta calculation
X = sm.add_constant(returns['BTC'])
model = OLS(returns['MSTR'], X).fit()
alpha = model.params[0]
beta = model.params[1]
r_squared = model.rsquared

# Run ADF test on the ratio to check for stationarity
adf_result = adfuller(data['Ratio'].dropna())
adf_pvalue = adf_result[1]

# Define thresholds for different strategies
thresholds = [0.5, 1.0, 1.5, 2.0, 2.5]

# Create a real backtesting function
def backtest_pairs_strategy(data, threshold, risk_free_rate=0.04):
    """Run a real backtest for pairs trading with a specific threshold"""

    # Make a copy of the dataframe to avoid modifying the original
    df = data.copy()

    # Create position signals based on Z-score
    # 1 = Long MSTR, Short BTC
    # -1 = Short MSTR, Long BTC
    # 0 = No position
    df['Signal'] = 0
    df.loc[df['Z_Score'] < -threshold, 'Signal'] = 1  # Long MSTR, Short BTC
    df.loc[df['Z_Score'] > threshold, 'Signal'] = -1  # Short MSTR, Long BTC

    # To avoid lookahead bias, shift the signal by 1 day (use yesterday's signal for today's position)
    df['Position'] = df['Signal'].shift(1)
    df = df.dropna()  # Drop rows with NaN positions

    # Track trade entries and exits
    df['Entry'] = df['Position'] != df['Position'].shift(1)
    df['Exit'] = df['Position'].shift(1) != 0
    df.loc[df['Entry'] & df['Exit'], 'Exit'] = False  # If both entry and exit, it's an entry

    # Calculate position values (assume equal dollar amounts in both legs)
    df['MSTR_Position'] = df['Position'] * 1  # +1 for long, -1 for short
    df['BTC_Position'] = -df['Position'] * 1  # Opposite of MSTR position

    # Calculate daily returns for the strategy
    df['MSTR_Return'] = returns['MSTR'].loc[df.index] * df['MSTR_Position']
    df['BTC_Return'] = returns['BTC'].loc[df.index] * df['BTC_Position']
    df['Strategy_Return'] = df['MSTR_Return'] + df['BTC_Return']

    # Calculate cumulative returns
    df['Cumulative_Return'] = (1 + df['Strategy_Return']).cumprod()

    # Calculate drawdown
    df['Peak'] = df['Cumulative_Return'].cummax()
    df['Drawdown'] = (df['Cumulative_Return'] / df['Peak'] - 1) * 100  # in percentage

    # Calculate trade details
    trades = []
    current_trade = None

    for date, row in df.iterrows():
        if row['Entry'] and row['Position'] != 0:
            # Start a new trade
            current_trade = {
                'Entry_Date': date,
                'Entry_Type': 'Long MSTR/Short BTC' if row['Position'] > 0 else 'Short MSTR/Long BTC',
                'Entry_MSTR_Price': row['MSTR'],
                'Entry_BTC_Price': row['BTC'],
                'Entry_Ratio': row['Ratio'],
                'Entry_Z_Score': row['Z_Score'],
                'Position': row['Position']
            }
        elif row['Exit'] and current_trade is not None:
            # Close an existing trade
            current_trade['Exit_Date'] = date
            current_trade['Exit_MSTR_Price'] = row['MSTR']
            current_trade['Exit_BTC_Price'] = row['BTC']
            current_trade['Exit_Ratio'] = row['Ratio']
            current_trade['Exit_Z_Score'] = row['Z_Score']

            # Calculate trade returns
            if current_trade['Position'] > 0:  # Long MSTR/Short BTC
                mstr_return = (row['MSTR'] / current_trade['Entry_MSTR_Price'] - 1)
                btc_return = (current_trade['Entry_BTC_Price'] / row['BTC'] - 1)
            else:  # Short MSTR/Long BTC
                mstr_return = (current_trade['Entry_MSTR_Price'] / row['MSTR'] - 1)
                btc_return = (row['BTC'] / current_trade['Entry_BTC_Price'] - 1)

            current_trade['MSTR_Return'] = mstr_return
            current_trade['BTC_Return'] = btc_return
            current_trade['Total_Return'] = mstr_return + btc_return
            current_trade['Duration'] = (date - current_trade['Entry_Date']).days

            trades.append(current_trade)
            current_trade = None

    # Calculate performance metrics
    total_days = len(df)
    position_days = (df['Position'] != 0).sum()
    position_days_ratio = position_days / total_days

    win_days = (df['Strategy_Return'] > 0).sum()
    win_ratio = win_days / total_days

    trade_count = len(trades)
    if trade_count > 0:
        winning_trades = sum(1 for trade in trades if trade['Total_Return'] > 0)
        win_trade_ratio = winning_trades / trade_count
        avg_trade_return = sum(trade['Total_Return'] for trade in trades) / trade_count
        avg_trade_duration = sum(trade['Duration'] for trade in trades) / trade_count
    else:
        winning_trades = 0
        win_trade_ratio = 0
        avg_trade_return = 0
        avg_trade_duration = 0

    # Calculate annualized metrics
    annual_factor = 252 / total_days

    if len(df) > 0:
        annual_return = df['Cumulative_Return'].iloc[-1] ** annual_factor - 1
        annual_volatility = df['Strategy_Return'].std() * np.sqrt(252)
        sharpe_ratio = (annual_return - risk_free_rate) / annual_volatility if annual_volatility > 0 else 0
        max_drawdown = df['Drawdown'].min()
    else:
        annual_return = 0
        annual_volatility = 0
        sharpe_ratio = 0
        max_drawdown = 0

    return {
        'Data': df,
        'Trades': trades,
        'Annual_Return': annual_return,
        'Annual_Volatility': annual_volatility,
        'Sharpe_Ratio': sharpe_ratio,
        'Max_Drawdown': max_drawdown,
        'Trade_Count': trade_count,
        'Win_Trade_Ratio': win_trade_ratio,
        'Avg_Trade_Return': avg_trade_return,
        'Avg_Trade_Duration': avg_trade_duration,
        'Position_Days_Ratio': position_days_ratio,
        'Win_Ratio': win_ratio
    }

# Run backtests for different Z-score thresholds
backtest_results = {}
for threshold in thresholds:
    backtest_results[f'Pairs_Z{threshold}'] = backtest_pairs_strategy(data, threshold)

# Calculate buy-and-hold returns for BTC and MSTR
# Align with backtest date range
first_date = list(backtest_results.values())[0]['Data'].index[0]
last_date = list(backtest_results.values())[0]['Data'].index[-1]

btc_aligned = data.loc[first_date:last_date, 'BTC']
mstr_aligned = data.loc[first_date:last_date, 'MSTR']

btc_return = (btc_aligned[-1] / btc_aligned[0]) - 1
mstr_return = (mstr_aligned[-1] / mstr_aligned[0]) - 1

# Calculate daily buy-and-hold returns
btc_daily_returns = returns.loc[first_date:last_date, 'BTC']
mstr_daily_returns = returns.loc[first_date:last_date, 'MSTR']

btc_cum_returns = (1 + btc_daily_returns).cumprod()
mstr_cum_returns = (1 + mstr_daily_returns).cumprod()

# Calculate buy-and-hold performance metrics
def calculate_buy_hold_metrics(returns, cum_returns, risk_free_rate=0.04):
    annual_return = cum_returns.iloc[-1] ** (252 / len(returns)) - 1
    annual_volatility = returns.std() * np.sqrt(252)
    sharpe_ratio = (annual_return - risk_free_rate) / annual_volatility if annual_volatility > 0 else 0

    # Calculate drawdown
    running_max = cum_returns.cummax()
    drawdown = (cum_returns / running_max - 1) * 100  # in percentage
    max_drawdown = drawdown.min()

    return {
        'Returns': returns,
        'Cumulative': cum_returns,
        'Annual_Return': annual_return,
        'Annual_Volatility': annual_volatility,
        'Sharpe_Ratio': sharpe_ratio,
        'Max_Drawdown': max_drawdown
    }

# Add buy-and-hold strategies to backtest results
backtest_results['Hold_BTC'] = calculate_buy_hold_metrics(btc_daily_returns, btc_cum_returns)
backtest_results['Hold_MSTR'] = calculate_buy_hold_metrics(mstr_daily_returns, mstr_cum_returns)

# Prepare performance summary DataFrame
performance_data = {}
for strategy, results in backtest_results.items():
    performance_data[strategy] = {
        'Annual_Return': results['Annual_Return'] if strategy.startswith('Pairs') else results['Annual_Return'],
        'Annual_Volatility': results['Annual_Volatility'] if strategy.startswith('Pairs') else results['Annual_Volatility'],
        'Sharpe_Ratio': results['Sharpe_Ratio'] if strategy.startswith('Pairs') else results['Sharpe_Ratio'],
        'Max_Drawdown': results['Max_Drawdown'] if strategy.startswith('Pairs') else results['Max_Drawdown']
    }

    if strategy.startswith('Pairs'):
        performance_data[strategy]['Trade_Count'] = results.get('Trade_Count', np.nan)
        performance_data[strategy]['Position_Days_Ratio'] = results.get('Position_Days_Ratio', np.nan)
        performance_data[strategy]['Win_Ratio'] = results.get('Win_Ratio', np.nan)

# Convert to DataFrame
performance_df = pd.DataFrame.from_dict(performance_data, orient='index')

# Rename columns for display
performance_df = performance_df.rename(columns={
    'Annual_Return': 'Annual Return',
    'Annual_Volatility': 'Annual Volatility',
    'Sharpe_Ratio': 'Sharpe Ratio',
    'Max_Drawdown': 'Max Drawdown',
    'Trade_Count': 'Trade Count',
    'Position_Days_Ratio': 'Position Days Ratio',
    'Win_Ratio': 'Win Ratio'
})

# Format for display
display_df = performance_df.copy()
for col in ['Annual Return', 'Annual Volatility', 'Max Drawdown']:
    if col in display_df.columns:
        display_df[col] = display_df[col].map('{:.2%}'.format)
if 'Sharpe Ratio' in display_df.columns:
    display_df['Sharpe Ratio'] = display_df['Sharpe Ratio'].map('{:.2f}'.format)
if 'Win Ratio' in display_df.columns:
    display_df['Win Ratio'] = display_df['Win Ratio'].fillna('').map(lambda x: '{:.2%}'.format(x) if x != '' else '')
if 'Position Days Ratio' in display_df.columns:
    display_df['Position Days Ratio'] = display_df['Position Days Ratio'].fillna('').map(lambda x: '{:.2%}'.format(x) if x != '' else '')
if 'Trade Count' in display_df.columns:
    display_df['Trade Count'] = display_df['Trade Count'].fillna('').map(lambda x: '{:.0f}'.format(x) if x != '' else '')

# Find the best strategy based on Sharpe ratio
best_pairs_strategy = performance_df[performance_df.index.str.startswith('Pairs_')]['Sharpe Ratio'].idxmax()
best_pairs_sharpe = performance_df.loc[best_pairs_strategy, 'Sharpe Ratio']
best_overall_strategy = performance_df['Sharpe Ratio'].idxmax()
best_overall_sharpe = performance_df.loc[best_overall_strategy, 'Sharpe Ratio']

# Extract trades for all strategies
trade_metrics = {}
for threshold in thresholds:
    strategy = f'Pairs_Z{threshold}'
    trades = backtest_results[strategy]['Trades']

    if trades:
        winning_trades = sum(1 for trade in trades if trade['Total_Return'] > 0)
        win_rate = winning_trades / len(trades) if len(trades) > 0 else 0
        avg_return = sum(trade['Total_Return'] for trade in trades) / len(trades) if len(trades) > 0 else 0
        avg_duration = sum(trade['Duration'] for trade in trades) / len(trades) if len(trades) > 0 else 0

        trade_metrics[strategy] = {
            'Count': len(trades),
            'Win Rate': win_rate,
            'Avg Return': avg_return,
            'Avg Duration': avg_duration
        }
    else:
        trade_metrics[strategy] = {
            'Count': 0,
            'Win Rate': 0,
            'Avg Return': 0,
            'Avg Duration': 0
        }

# Convert trade metrics to DataFrame for display
trade_metrics_df = pd.DataFrame.from_dict(trade_metrics, orient='index')
```

# MSTR-BTC Pairs Trading Strategy

## Strategy Overview

This trading strategy exploits the statistical relationship between MicroStrategy (MSTR) stock and Bitcoin (BTC). Since MicroStrategy has adopted a strategy of holding substantial Bitcoin reserves on its balance sheet, the two assets demonstrate a high correlation while occasionally experiencing temporary price divergences. The strategy aims to capitalize on these divergences through pairs trading techniques.

### Key Components

- **Assets**: MicroStrategy (MSTR) and Bitcoin (BTC)
- **Relationship**: Statistical arbitrage based on price ratio mean-reversion
- **Method**: Z-score trading signals with varying thresholds
- **Time Frame**: Daily trading (based on daily price data)
- **Market Approach**: Market-neutral strategy that can work in various market conditions

## Data Analysis

### MSTR and BTC Price Relationship

```{python}
#| echo: false
#| warning: false

# Create a subplot with two Y-axes
fig = make_subplots(specs=[[{"secondary_y": True}]])

# Add MSTR price line
fig.add_trace(
    go.Scatter(x=data.index, y=data['MSTR'], name="MSTR", line=dict(color='blue')),
    secondary_y=False,
)

# Add BTC price line
fig.add_trace(
    go.Scatter(x=data.index, y=data['BTC'], name="BTC", line=dict(color='red')),
    secondary_y=True,
)

# Set title and axis labels
fig.update_layout(
    title_text="MSTR vs BTC Price Trends",
    hovermode="x unified"
)

fig.update_xaxes(title_text="Date")
fig.update_yaxes(title_text="MSTR Price ($)", secondary_y=False, color='blue')
fig.update_yaxes(title_text="BTC Price ($)", secondary_y=True, color='red')

# Add range slider for interactive zooming
fig.update_layout(
    xaxis=dict(
        rangeslider=dict(visible=True),
        type="date"
    ),
    height=500
)

fig.show()
```

The relationship between MSTR and BTC prices forms the foundation of our pairs trading strategy. The chart above shows the price trends of both assets with MSTR on the left axis and BTC on the right axis. Below you can see the Z-score that drives our trading signals:

```{python}
#| echo: false
#| warning: false
#| message: false

# Define Z-Score threshold lines
thresholds_zlines = [-3, -2, -1, 0, 1, 2, 3]

# Create subplots with secondary y-axis
fig = make_subplots(specs=[[{"secondary_y": True}]])

# (1) MSTR/BTC Ratio
fig.add_trace(
    go.Scatter(
        x=data.index,
        y=data['Ratio'],
        name="MSTR/BTC Ratio",
        line=dict(color='green')
    ),
    secondary_y=False
)

# (2) 20-day Moving Average
fig.add_trace(
    go.Scatter(
        x=data.index,
        y=data['Ratio_MA'],
        name="20-day MA",
        line=dict(color='black', dash='dash')
    ),
    secondary_y=False
)

# (3) Mean Ratio
mean_ratio = data['Ratio'].mean()
fig.add_trace(
    go.Scatter(
        x=data.index,
        y=[mean_ratio] * len(data),
        name="Mean Ratio",
        line=dict(color='red')
    ),
    secondary_y=False
)

# (4) Z-Score (secondary axis)
fig.add_trace(
    go.Scatter(
        x=data.index,
        y=data['Z_Score'],
        name="Z-Score",
        line=dict(color='purple')
    ),
    secondary_y=True
)

# (5) Z-Score horizontal threshold lines
for thr in thresholds_zlines:
    fig.add_trace(
        go.Scatter(
            x=data.index,
            y=[thr] * len(data),
            mode='lines',
            line=dict(color='pink', width=1, dash='dot'),
            name=f"Z = {thr}",
            showlegend=(thr == 0)  # only show legend once
        ),
        secondary_y=True
    )

# Layout setup
fig.update_layout(
    title="MSTR vs BTC Price Ratio and Z-Score",
    hovermode="x unified",
    xaxis=dict(
        title="Date",
        rangeslider=dict(visible=True),
        type="date"
    ),
    yaxis=dict(
        title="MSTR/BTC Ratio",
        tickformat=".4f"
    ),
    yaxis2=dict(
        title="Z-Score",
        overlaying='y',
        side='right'
    ),
    legend_title="Legend",
    height=600
)

fig.show()
```

### Statistical Relationship Analysis

The key metrics that validate our pairs trading approach:

```{python}
#| echo: false
#| warning: false
#| message: false

# Create table of metrics using actual calculated values
metrics = pd.DataFrame({
    'Metric': ['Correlation Coefficient', 'Beta (MSTR to BTC)',
               'Average Price Ratio', 'Price Ratio StdDev', 'ADF Test p-value'],
    'Value': [f'{returns["MSTR"].corr(returns["BTC"]):.4f}',
              f'{beta:.4f}',
              f'{data["Ratio"].mean():.4f}',
              f'{data["Ratio"].std():.4f}',
              f'{adf_pvalue:.4f} ({"Stationary" if adf_pvalue < 0.05 else "Non-stationary"})']
})

metrics
```

## Backtest Results

The performance of our pairs trading strategy with different Z-score thresholds compared to buy-and-hold strategies:

```{python}
#| echo: false
#| warning: false
#| message: false

# Display the performance dataframe
display_df
```

### Best Strategy Analysis

```{python}
#| echo: false
#| warning: false
#| message: false

# Create a summary of the best strategies
best_strategies = pd.DataFrame([
    {'Strategy Type': 'Best Pairs Strategy', 'Strategy': best_pairs_strategy, 'Sharpe Ratio': best_pairs_sharpe},
    {'Strategy Type': 'Best Overall Strategy', 'Strategy': best_overall_strategy, 'Sharpe Ratio': best_overall_sharpe}
])

# Format the Sharpe ratio for display
best_strategies['Sharpe Ratio'] = best_strategies['Sharpe Ratio'].map('{:.2f}'.format)

# Display the best strategies
best_strategies
```

### Strategy Returns Visualization

The cumulative returns of all strategies:

```{python}
#| echo: false
#| warning: false

# Create DataFrame for cumulative return comparison
cum_returns_data_all = pd.DataFrame()

# Add pairs trading strategies
for threshold in thresholds:
    strategy = f'Pairs_Z{threshold}'
    cum_returns_data_all[strategy] = backtest_results[strategy]['Data']['Cumulative_Return']

# Add buy-and-hold strategies
cum_returns_data_all['Hold_MSTR'] = backtest_results['Hold_MSTR']['Cumulative']
cum_returns_data_all['Hold_BTC'] = backtest_results['Hold_BTC']['Cumulative']

# Reset index for plotting
cum_returns_data_all = cum_returns_data_all.reset_index()
cum_returns_data_all = cum_returns_data_all.rename(columns={'index': 'date'})

# Create interactive cumulative return plot
fig = px.line(
    cum_returns_data_all,
    x='date',
    y=cum_returns_data_all.columns[1:],
    title='Cumulative Returns of All Strategies',
    labels={
        'value': 'Cumulative Return (Initial Investment = 1)',
        'variable': 'Strategy'
    }
)

fig.update_layout(
    xaxis=dict(
        rangeslider=dict(visible=True),
        type="date"
    ),
    yaxis_title="Cumulative Return (Initial Investment = 1)",
    legend_title="Strategy",
    height=550,
    hovermode="x unified"
)

fig.show()
```

### Risk-Return Profile

```{python}
#| echo: false
#| warning: false

# Create risk-return table from actual backtest results
risk_return_table = performance_df[['Annual Return', 'Annual Volatility', 'Sharpe Ratio']].copy()

# Format for display
for col in ['Annual Return', 'Annual Volatility']:
    risk_return_table[col] = risk_return_table[col].map('{:.2%}'.format)
risk_return_table['Sharpe Ratio'] = risk_return_table['Sharpe Ratio'].map('{:.2f}'.format)

# Display as table
risk_return_table
```

### Drawdown Analysis

```{python}
#| echo: false
#| warning: false

# Get the best pairs strategy based on Sharpe ratio
best_strategy = best_pairs_strategy

# Calculate drawdown for best pairs strategy
pairs_drawdown = backtest_results[best_strategy]['Data']['Drawdown']

# Calculate drawdowns for buy and hold strategies
mstr_returns = backtest_results['Hold_MSTR']['Returns']
btc_returns = backtest_results['Hold_BTC']['Returns']

mstr_cum_returns = backtest_results['Hold_MSTR']['Cumulative']
btc_cum_returns = backtest_results['Hold_BTC']['Cumulative']

# Calculate drawdown series for both assets
mstr_running_max = mstr_cum_returns.cummax()
mstr_drawdown = (mstr_cum_returns / mstr_running_max - 1) * 100

btc_running_max = btc_cum_returns.cummax()
btc_drawdown = (btc_cum_returns / btc_running_max - 1) * 100

# Create DataFrame for plotting
drawdown_data = pd.DataFrame({
    'Date': pairs_drawdown.index,
    best_strategy: pairs_drawdown,
    'Hold_MSTR': mstr_drawdown,
    'Hold_BTC': btc_drawdown
})

# Reset index for plotting
drawdown_data = drawdown_data.reset_index(drop=True)

# Create drawdown chart
fig = px.line(drawdown_data, x='Date', y=[best_strategy, 'Hold_MSTR', 'Hold_BTC'],
             title='Drawdown Comparison',
             labels={'value': 'Drawdown (%)', 'variable': 'Strategy'},
             color_discrete_map={
                 best_strategy: 'green',
                 'Hold_MSTR': 'blue',
                 'Hold_BTC': 'red'
             })

# Add rangeslider for interactive zooming
fig.update_layout(
    xaxis=dict(
        rangeslider=dict(visible=True),
        type="date"
    ),
    yaxis_title="Drawdown (%)",
    legend_title="Strategy",
    height=500,
    hovermode="x unified"
)

# Add zero line
fig.add_hline(y=0, line_dash="solid", line_color="black", opacity=0.3)

fig.show()
```

## Trading Analysis

### Trade Performance by Z-Score Threshold

```{python}
#| echo: false
#| warning: false

# Format trade metrics for display
trade_metrics_df_display = trade_metrics_df.copy()
trade_metrics_df_display['Win Rate'] = trade_metrics_df_display['Win Rate'].map('{:.2%}'.format)
trade_metrics_df_display['Avg Return'] = trade_metrics_df_display['Avg Return'].map('{:.2%}'.format)
trade_metrics_df_display['Avg Duration'] = trade_metrics_df_display['Avg Duration'].map('{:.1f} days'.format)

# Display table
trade_metrics_df_display
```

### Position Analysis Over Time

```{python}
#| echo: false
#| warning: false

# Get position data for best pairs strategy
best_strategy = best_pairs_strategy
threshold = float(best_strategy.split('Z')[1])  # Extract threshold from strategy name
position_data = backtest_results[best_strategy]['Data'][['Position', 'Z_Score', 'MSTR', 'BTC']]

# Create scatter plot with positions
fig = go.Figure()

# Plot Z-Score
fig.add_trace(
    go.Scatter(
        x=position_data.index,
        y=position_data['Z_Score'],
        mode='lines',
        name='Z-Score',
        line=dict(color='purple')
    )
)

# Add threshold lines
fig.add_hline(y=threshold, line_dash="dash", line_color="red", annotation_text=f"Upper Threshold ({threshold})")
fig.add_hline(y=-threshold, line_dash="dash", line_color="red", annotation_text=f"Lower Threshold (-{threshold})")
fig.add_hline(y=0, line_dash="solid", line_color="black", opacity=0.3)

# Add points for long positions
long_positions = position_data[position_data['Position'] > 0]
if not long_positions.empty:
    fig.add_trace(
        go.Scatter(
            x=long_positions.index,
            y=long_positions['Z_Score'],
            mode='markers',
            name='Long MSTR/Short BTC',
            marker=dict(color='green', size=8, symbol='triangle-up')
        )
    )

# Add points for short positions
short_positions = position_data[position_data['Position'] < 0]
if not short_positions.empty:
    fig.add_trace(
        go.Scatter(
            x=short_positions.index,
            y=short_positions['Z_Score'],
            mode='markers',
            name='Short MSTR/Long BTC',
            marker=dict(color='red', size=8, symbol='triangle-down')
        )
    )

# Layout setup
fig.update_layout(
    title=f"Z-Score and Trading Positions (Threshold = {threshold})",
    xaxis_title="Date",
    yaxis_title="Z-Score",
    hovermode="x unified",
    height=500
)

fig.show()
```

### Sharpe Ratio Comparison

```{python}
#| echo: false
#| warning: false

# Extract Sharpe ratios for each strategy
sharpe_ratios = {strategy: performance_df.loc[strategy, 'Sharpe Ratio']
                for strategy in performance_df.index}

# Create bar chart of Sharpe ratios
fig = px.bar(
    x=list(sharpe_ratios.keys()),
    y=list(sharpe_ratios.values()),
    title='Sharpe Ratio Comparison Across Strategies',
    labels={'x': 'Strategy', 'y': 'Sharpe Ratio'},
    color=list(sharpe_ratios.keys()),
    color_discrete_map={
        'Hold_MSTR': 'blue',
        'Hold_BTC': 'red',
        'Pairs_Z0.5': 'lightgreen',
        'Pairs_Z1.0': 'green',
        'Pairs_Z1.5': 'darkgreen',
        'Pairs_Z2.0': 'darkblue',
        'Pairs_Z2.5': 'purple'
    }
)

# Add a line for zero Sharpe ratio
fig.add_hline(y=0, line_dash="dash", line_color="gray")

# Layout setup
fig.update_layout(
    xaxis_title="Strategy",
    yaxis_title="Sharpe Ratio",
    height=400
)

fig.show()
```

### Trade Win Rate vs Z-Score Threshold

```{python}
#| echo: false
#| warning: false

# Prepare data for win rate comparison
win_rates = []
for threshold in thresholds:
    strategy = f'Pairs_Z{threshold}'
    if 'Win Rate' in trade_metrics.get(strategy, {}):
        win_rate = trade_metrics[strategy]['Win Rate']
        win_rates.append({'Threshold': threshold, 'Win Rate': win_rate})
    else:
        # If win rate isn't available, calculate it from trades
        trades = backtest_results[strategy]['Trades']
        if trades:
            winning_trades = sum(1 for trade in trades if trade['Total_Return'] > 0)
            win_rate = winning_trades / len(trades)
            win_rates.append({'Threshold': threshold, 'Win Rate': win_rate})
        else:
            win_rates.append({'Threshold': threshold, 'Win Rate': 0})

win_rates_df = pd.DataFrame(win_rates)

# Create bar chart
fig = px.bar(
    win_rates_df,
    x='Threshold',
    y='Win Rate',
    title='Trade Win Rate by Z-Score Threshold',
    labels={'Threshold': 'Z-Score Threshold', 'Win Rate': 'Win Rate'},
    color='Threshold',
    color_continuous_scale='Viridis'
)

fig.update_layout(
    xaxis_title="Z-Score Threshold",
    yaxis_title="Win Rate",
    yaxis_tickformat='.0%',
    height=400
)

fig.show()
```

## Conclusion

This pairs trading strategy exploiting the MSTR-BTC relationship provides a market-neutral approach that can complement traditional long-only cryptocurrency and equity strategies. Based on our real market data analysis, the optimal configuration uses a Z-score threshold of 2.5, which provides the best Sharpe ratio among pairs strategies at 0.51.

While our backtest shows that simply holding MSTR would have yielded higher absolute returns with a Sharpe ratio of 2.89, the pairs trading approach demonstrates significantly better risk characteristics:

1. **Lower Maximum Drawdown** for pairs trading vs. holding MSTR
2. **Lower Volatility** for pairs trading vs. holding MSTR

The strategy's key advantage is its reduced drawdown and lower volatility compared to holding either asset individually, making it valuable for portfolio diversification. The Z-score threshold of 2.5 offers fewer but higher quality trades with a 50% win rate.

Future enhancements will include machine learning-based signal generation and intraday trading capability.