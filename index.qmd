---
title: "MSTR-BTC Pairs Trading Strategy"
author: "Jack Li, Bill Wang, Paul Zhao"
date: "April 25, 2025"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
---

```{=html}
<!-- GitHub Button with improved positioning to avoid overlap with search button -->
<style>
/* Styles for GitHub button to be placed in the Quarto navbar */
.navbar-github-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 4px;
  border-radius: 4px;
  transition: background-color 0.2s;
  margin-right: 15px; /* Add more margin to avoid overlap */
}

.navbar-github-button:hover {
  background-color: rgba(0, 0, 0, 0.1);
}

.navbar-github-button svg {
  width: 24px;
  height: 24px;
  fill: currentColor;
}

/* Move the search button to the left a bit */
.quarto-search {
  margin-right: 50px !important; /* Add important to override default styles */
}
</style>

<!-- Script to inject the GitHub button into the navbar after page loads -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  // Create GitHub button element
  var githubButton = document.createElement('a');
  githubButton.className = 'navbar-github-button';
  githubButton.href = 'https://github.com/Aspros-paul/QFDteam_533';
  githubButton.target = '_blank';
  githubButton.setAttribute('aria-label', 'View on GitHub');
  githubButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"/></svg>';

  // Function to handle navbar insertion with better positioning
  function insertGitHubButton() {
    // First, try to find the search button
    var searchButton = document.querySelector('.quarto-search');

    if (searchButton) {
      // Move the search button to the left
      searchButton.style.marginRight = '50px';

      // Insert our GitHub button after the search button
      searchButton.parentNode.insertBefore(githubButton, searchButton.nextSibling);
    } else {
      // If search button isn't found, try the right navbar section
      var navbarRight = document.querySelector('.navbar-nav.navbar-nav-scroll.ms-auto');
      if (navbarRight) {
        // Create a list item for the button
        var listItem = document.createElement('li');
        listItem.className = 'nav-item';
        listItem.appendChild(githubButton);

        // Insert at the end of the right navbar
        navbarRight.appendChild(listItem);
      } else {
        // Final fallback - if we can't find the right navbar section, append to the navbar container
        var navbar = document.querySelector('.navbar-container');
        if (navbar) {
          navbar.appendChild(githubButton);
        }
      }
    }
  }

  // Try inserting immediately
  insertGitHubButton();

  // Also try after a slight delay to ensure all Quarto elements are fully rendered
  setTimeout(insertGitHubButton, 500);
});
</script>
```

```{python}
#| echo: false
#| warning: false
#| message: false

# Load necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import statsmodels.api as sm
from statsmodels.regression.linear_model import OLS
from statsmodels.tsa.stattools import adfuller
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import datetime

# Load real data from CSV
data = pd.read_csv('data/mstr_btc_data_2Y_daily.csv', index_col=0, parse_dates=True)

# Calculate returns
returns = data.pct_change().dropna()

# Calculate ratio and Z-score
data['Ratio'] = data['MSTR'] / data['BTC']
data['Ratio_MA'] = data['Ratio'].rolling(window=20).mean()
data['Ratio_STD'] = data['Ratio'].rolling(window=20).std()
data['Z_Score'] = (data['Ratio'] - data['Ratio_MA']) / data['Ratio_STD']

# Drop NaN values after calculations
data = data.dropna()

# Run regression analysis for beta calculation
X = sm.add_constant(returns['BTC'])
model = OLS(returns['MSTR'], X).fit()
alpha = model.params[0]
beta = model.params[1]
r_squared = model.rsquared

# Run ADF test on the ratio to check for stationarity
adf_result = adfuller(data['Ratio'].dropna())
adf_pvalue = adf_result[1]

# Define thresholds for different strategies
thresholds = [0.5, 1.0, 1.5, 2.0, 2.5]

# Create a real backtesting function
def backtest_pairs_strategy(data, threshold, risk_free_rate=0.04):
    """Run a real backtest for pairs trading with a specific threshold"""

    # Make a copy of the dataframe to avoid modifying the original
    df = data.copy()

    # Create position signals based on Z-score
    # 1 = Long MSTR, Short BTC
    # -1 = Short MSTR, Long BTC
    # 0 = No position
    df['Signal'] = 0
    df.loc[df['Z_Score'] < -threshold, 'Signal'] = 1  # Long MSTR, Short BTC
    df.loc[df['Z_Score'] > threshold, 'Signal'] = -1  # Short MSTR, Long BTC

    # To avoid lookahead bias, shift the signal by 1 day (use yesterday's signal for today's position)
    df['Position'] = df['Signal'].shift(1)
    df = df.dropna()  # Drop rows with NaN positions

    # Track trade entries and exits
    df['Entry'] = df['Position'] != df['Position'].shift(1)
    df['Exit'] = df['Position'].shift(1) != 0
    df.loc[df['Entry'] & df['Exit'], 'Exit'] = False  # If both entry and exit, it's an entry

    # Calculate position values (assume equal dollar amounts in both legs)
    df['MSTR_Position'] = df['Position'] * 1  # +1 for long, -1 for short
    df['BTC_Position'] = -df['Position'] * 1  # Opposite of MSTR position

    # Calculate daily returns for the strategy
    df['MSTR_Return'] = returns['MSTR'].loc[df.index] * df['MSTR_Position']
    df['BTC_Return'] = returns['BTC'].loc[df.index] * df['BTC_Position']
    df['Strategy_Return'] = df['MSTR_Return'] + df['BTC_Return']

    # Calculate cumulative returns
    df['Cumulative_Return'] = (1 + df['Strategy_Return']).cumprod()

    # Calculate drawdown
    df['Peak'] = df['Cumulative_Return'].cummax()
    df['Drawdown'] = (df['Cumulative_Return'] / df['Peak'] - 1) * 100  # in percentage

    # Calculate trade details
    trades = []
    current_trade = None

    for date, row in df.iterrows():
        if row['Entry'] and row['Position'] != 0:
            # Start a new trade
            current_trade = {
                'Entry_Date': date,
                'Entry_Type': 'Long MSTR/Short BTC' if row['Position'] > 0 else 'Short MSTR/Long BTC',
                'Entry_MSTR_Price': row['MSTR'],
                'Entry_BTC_Price': row['BTC'],
                'Entry_Ratio': row['Ratio'],
                'Entry_Z_Score': row['Z_Score'],
                'Position': row['Position']
            }
        elif row['Exit'] and current_trade is not None:
            # Close an existing trade
            current_trade['Exit_Date'] = date
            current_trade['Exit_MSTR_Price'] = row['MSTR']
            current_trade['Exit_BTC_Price'] = row['BTC']
            current_trade['Exit_Ratio'] = row['Ratio']
            current_trade['Exit_Z_Score'] = row['Z_Score']

            # Calculate trade returns
            if current_trade['Position'] > 0:  # Long MSTR/Short BTC
                mstr_return = (row['MSTR'] / current_trade['Entry_MSTR_Price'] - 1)
                btc_return = (current_trade['Entry_BTC_Price'] / row['BTC'] - 1)
            else:  # Short MSTR/Long BTC
                mstr_return = (current_trade['Entry_MSTR_Price'] / row['MSTR'] - 1)
                btc_return = (row['BTC'] / current_trade['Entry_BTC_Price'] - 1)

            current_trade['MSTR_Return'] = mstr_return
            current_trade['BTC_Return'] = btc_return
            current_trade['Total_Return'] = mstr_return + btc_return
            current_trade['Duration'] = (date - current_trade['Entry_Date']).days

            trades.append(current_trade)
            current_trade = None

    # Calculate performance metrics
    total_days = len(df)
    position_days = (df['Position'] != 0).sum()
    position_days_ratio = position_days / total_days

    win_days = (df['Strategy_Return'] > 0).sum()
    win_ratio = win_days / total_days

    trade_count = len(trades)
    if trade_count > 0:
        winning_trades = sum(1 for trade in trades if trade['Total_Return'] > 0)
        win_trade_ratio = winning_trades / trade_count
        avg_trade_return = sum(trade['Total_Return'] for trade in trades) / trade_count
        avg_trade_duration = sum(trade['Duration'] for trade in trades) / trade_count
    else:
        winning_trades = 0
        win_trade_ratio = 0
        avg_trade_return = 0
        avg_trade_duration = 0

    # Calculate annualized metrics
    annual_factor = 252 / total_days

    if len(df) > 0:
        annual_return = df['Cumulative_Return'].iloc[-1] ** annual_factor - 1
        annual_volatility = df['Strategy_Return'].std() * np.sqrt(252)
        sharpe_ratio = (annual_return - risk_free_rate) / annual_volatility if annual_volatility > 0 else 0
        max_drawdown = df['Drawdown'].min()
    else:
        annual_return = 0
        annual_volatility = 0
        sharpe_ratio = 0
        max_drawdown = 0

    return {
        'Data': df,
        'Trades': trades,
        'Annual_Return': annual_return,
        'Annual_Volatility': annual_volatility,
        'Sharpe_Ratio': sharpe_ratio,
        'Max_Drawdown': max_drawdown,
        'Trade_Count': trade_count,
        'Win_Trade_Ratio': win_trade_ratio,
        'Avg_Trade_Return': avg_trade_return,
        'Avg_Trade_Duration': avg_trade_duration,
        'Position_Days_Ratio': position_days_ratio,
        'Win_Ratio': win_ratio
    }

# Run backtests for different Z-score thresholds
backtest_results = {}
for threshold in thresholds:
    backtest_results[f'Pairs_Z{threshold}'] = backtest_pairs_strategy(data, threshold)

# Calculate buy-and-hold returns for BTC and MSTR
# Align with backtest date range
first_date = list(backtest_results.values())[0]['Data'].index[0]
last_date = list(backtest_results.values())[0]['Data'].index[-1]

btc_aligned = data.loc[first_date:last_date, 'BTC']
mstr_aligned = data.loc[first_date:last_date, 'MSTR']

btc_return = (btc_aligned[-1] / btc_aligned[0]) - 1
mstr_return = (mstr_aligned[-1] / mstr_aligned[0]) - 1

# Calculate daily buy-and-hold returns
btc_daily_returns = returns.loc[first_date:last_date, 'BTC']
mstr_daily_returns = returns.loc[first_date:last_date, 'MSTR']

btc_cum_returns = (1 + btc_daily_returns).cumprod()
mstr_cum_returns = (1 + mstr_daily_returns).cumprod()

# Calculate buy-and-hold performance metrics
def calculate_buy_hold_metrics(returns, cum_returns, risk_free_rate=0.04):
    annual_return = cum_returns.iloc[-1] ** (252 / len(returns)) - 1
    annual_volatility = returns.std() * np.sqrt(252)
    sharpe_ratio = (annual_return - risk_free_rate) / annual_volatility if annual_volatility > 0 else 0

    # Calculate drawdown
    running_max = cum_returns.cummax()
    drawdown = (cum_returns / running_max - 1) * 100  # in percentage
    max_drawdown = drawdown.min()

    return {
        'Returns': returns,
        'Cumulative': cum_returns,
        'Annual_Return': annual_return,
        'Annual_Volatility': annual_volatility,
        'Sharpe_Ratio': sharpe_ratio,
        'Max_Drawdown': max_drawdown
    }

# Add buy-and-hold strategies to backtest results
backtest_results['Hold_BTC'] = calculate_buy_hold_metrics(btc_daily_returns, btc_cum_returns)
backtest_results['Hold_MSTR'] = calculate_buy_hold_metrics(mstr_daily_returns, mstr_cum_returns)

# Prepare performance summary DataFrame
performance_data = {}
for strategy, results in backtest_results.items():
    performance_data[strategy] = {
        'Annual_Return': results['Annual_Return'] if strategy.startswith('Pairs') else results['Annual_Return'],
        'Annual_Volatility': results['Annual_Volatility'] if strategy.startswith('Pairs') else results['Annual_Volatility'],
        'Sharpe_Ratio': results['Sharpe_Ratio'] if strategy.startswith('Pairs') else results['Sharpe_Ratio'],
        'Max_Drawdown': results['Max_Drawdown'] if strategy.startswith('Pairs') else results['Max_Drawdown']
    }

    if strategy.startswith('Pairs'):
        performance_data[strategy]['Trade_Count'] = results.get('Trade_Count', np.nan)
        performance_data[strategy]['Position_Days_Ratio'] = results.get('Position_Days_Ratio', np.nan)
        performance_data[strategy]['Win_Ratio'] = results.get('Win_Ratio', np.nan)

# Convert to DataFrame
performance_df = pd.DataFrame.from_dict(performance_data, orient='index')

# Rename columns for display
performance_df = performance_df.rename(columns={
    'Annual_Return': 'Annual Return',
    'Annual_Volatility': 'Annual Volatility',
    'Sharpe_Ratio': 'Sharpe Ratio',
    'Max_Drawdown': 'Max Drawdown',
    'Trade_Count': 'Trade Count',
    'Position_Days_Ratio': 'Position Days Ratio',
    'Win_Ratio': 'Win Ratio'
})

# Format for display
display_df = performance_df.copy()
for col in ['Annual Return', 'Annual Volatility']:
    if col in display_df.columns:
        display_df[col] = display_df[col].map('{:.2%}'.format)
if 'Max Drawdown' in display_df.columns:
    display_df['Max Drawdown'] = display_df['Max Drawdown'].map('{:.2f}%'.format)

if 'Sharpe Ratio' in display_df.columns:
    display_df['Sharpe Ratio'] = display_df['Sharpe Ratio'].map('{:.2f}'.format)
if 'Win Ratio' in display_df.columns:
    display_df['Win Ratio'] = display_df['Win Ratio'].fillna('').map(lambda x: '{:.2%}'.format(x) if x != '' else '')
if 'Position Days Ratio' in display_df.columns:
    display_df['Position Days Ratio'] = display_df['Position Days Ratio'].fillna('').map(lambda x: '{:.2%}'.format(x) if x != '' else '')
if 'Trade Count' in display_df.columns:
    display_df['Trade Count'] = display_df['Trade Count'].fillna('').map(lambda x: '{:.0f}'.format(x) if x != '' else '')

# Find the best strategy based on Sharpe ratio
best_pairs_strategy = performance_df[performance_df.index.str.startswith('Pairs_')]['Sharpe Ratio'].idxmax()
best_pairs_sharpe = performance_df.loc[best_pairs_strategy, 'Sharpe Ratio']
best_overall_strategy = performance_df['Sharpe Ratio'].idxmax()
best_overall_sharpe = performance_df.loc[best_overall_strategy, 'Sharpe Ratio']

# Extract trades for all strategies
trade_metrics = {}
for threshold in thresholds:
    strategy = f'Pairs_Z{threshold}'
    trades = backtest_results[strategy]['Trades']

    if trades:
        winning_trades = sum(1 for trade in trades if trade['Total_Return'] > 0)
        win_rate = winning_trades / len(trades) if len(trades) > 0 else 0
        avg_return = sum(trade['Total_Return'] for trade in trades) / len(trades) if len(trades) > 0 else 0
        avg_duration = sum(trade['Duration'] for trade in trades) / len(trades) if len(trades) > 0 else 0

        trade_metrics[strategy] = {
            'Count': len(trades),
            'Win Rate': win_rate,
            'Avg Return': avg_return,
            'Avg Duration': avg_duration
        }
    else:
        trade_metrics[strategy] = {
            'Count': 0,
            'Win Rate': 0,
            'Avg Return': 0,
            'Avg Duration': 0
        }

# Convert trade metrics to DataFrame for display
trade_metrics_df = pd.DataFrame.from_dict(trade_metrics, orient='index')
```

# MSTR-BTC Pairs Trading Strategy

## Strategy Overview

This trading strategy exploits the statistical relationship between MicroStrategy (MSTR) stock and Bitcoin (BTC). Since MicroStrategy has adopted a strategy of holding substantial Bitcoin reserves on its balance sheet, the two assets demonstrate a high correlation while occasionally experiencing temporary price divergences. The strategy aims to capitalize on these divergences through pairs trading techniques.

### Key Components

- **Assets**: MicroStrategy (MSTR) and Bitcoin (BTC)
- **Relationship**: Statistical arbitrage based on price ratio mean-reversion
- **Method**: Z-score trading signals with varying thresholds
- **Time Frame**: Daily trading (based on daily price data)
- **Market Approach**: Market-neutral strategy that can work in various market conditions

## Data Analysis

### MSTR and BTC Price Relationship

```{python}
#| echo: false
#| warning: false

# Create a subplot with two Y-axes
fig = make_subplots(specs=[[{"secondary_y": True}]])

# Add MSTR price line
fig.add_trace(
    go.Scatter(x=data.index, y=data['MSTR'], name="MSTR", line=dict(color='blue')),
    secondary_y=False,
)

# Add BTC price line
fig.add_trace(
    go.Scatter(x=data.index, y=data['BTC'], name="BTC", line=dict(color='red')),
    secondary_y=True,
)

# Set title and axis labels
fig.update_layout(
    title_text="MSTR vs BTC Price Trends",
    hovermode="x unified"
)

fig.update_xaxes(title_text="Date")
fig.update_yaxes(title_text="MSTR Price ($)", secondary_y=False, color='blue')
fig.update_yaxes(title_text="BTC Price ($)", secondary_y=True, color='red')

# Add range slider for interactive zooming
fig.update_layout(
    xaxis=dict(
        rangeslider=dict(visible=True),
        type="date"
    ),
    height=500
)

fig.show()
```

The relationship between MSTR and BTC prices forms the foundation of our pairs trading strategy. The chart above shows the price trends of both assets with MSTR on the left axis and BTC on the right axis. Below you can see the Z-score that drives our trading signals:

```{python}
#| echo: false
#| warning: false
#| message: false

# Define Z-Score threshold lines
thresholds_zlines = [-3, -2, -1, 0, 1, 2, 3]

# Create subplots with secondary y-axis
fig = make_subplots(specs=[[{"secondary_y": True}]])

# (1) MSTR/BTC Ratio
fig.add_trace(
    go.Scatter(
        x=data.index,
        y=data['Ratio'],
        name="MSTR/BTC Ratio",
        line=dict(color='green')
    ),
    secondary_y=False
)

# (2) 20-day Moving Average
fig.add_trace(
    go.Scatter(
        x=data.index,
        y=data['Ratio_MA'],
        name="20-day MA",
        line=dict(color='black', dash='dash')
    ),
    secondary_y=False
)

# (3) Mean Ratio
mean_ratio = data['Ratio'].mean()
fig.add_trace(
    go.Scatter(
        x=data.index,
        y=[mean_ratio] * len(data),
        name="Mean Ratio",
        line=dict(color='red')
    ),
    secondary_y=False
)

# (4) Z-Score (secondary axis)
fig.add_trace(
    go.Scatter(
        x=data.index,
        y=data['Z_Score'],
        name="Z-Score",
        line=dict(color='purple')
    ),
    secondary_y=True
)

# (5) Z-Score horizontal threshold lines
for thr in thresholds_zlines:
    fig.add_trace(
        go.Scatter(
            x=data.index,
            y=[thr] * len(data),
            mode='lines',
            line=dict(color='pink', width=1, dash='dot'),
            name=f"Z = {thr}",
            showlegend=(thr == 0)  # only show legend once
        ),
        secondary_y=True
    )

# Layout setup
fig.update_layout(
    title="MSTR vs BTC Price Ratio and Z-Score",
    hovermode="x unified",
    xaxis=dict(
        title="Date",
        rangeslider=dict(visible=True),
        type="date"
    ),
    yaxis=dict(
        title="MSTR/BTC Ratio",
        tickformat=".4f"
    ),
    yaxis2=dict(
        title="Z-Score",
        overlaying='y',
        side='right'
    ),
    legend_title="Legend",
    height=600
)

fig.show()
```

### Statistical Relationship Analysis

The key metrics that validate our pairs trading approach:

```{python}
#| echo: false
#| warning: false
#| message: false

# Create table of metrics using actual calculated values
metrics = pd.DataFrame({
    'Metric': ['Correlation Coefficient', 'Beta (MSTR to BTC)',
               'Average Price Ratio', 'Price Ratio StdDev', 'ADF Test p-value'],
    'Value': [f'{returns["MSTR"].corr(returns["BTC"]):.4f}',
              f'{beta:.4f}',
              f'{data["Ratio"].mean():.4f}',
              f'{data["Ratio"].std():.4f}',
              f'{adf_pvalue:.4f} ({"Stationary" if adf_pvalue < 0.05 else "Non-stationary"})']
})

metrics
```
## Trade Entry and Exit Mechanism

### Z-Score Calculation

The core of our pairs trading strategy revolves around a statistical measure called the Z-score. This metric quantifies how far the MSTR/BTC price ratio deviates from its historical mean in terms of standard deviations:

1. We first calculate the daily ratio between MSTR and BTC prices:
   ```python
   data['Ratio'] = data['MSTR'] / data['BTC']
   ```

2. Then we calculate a 20-day moving average and standard deviation of this ratio:
   ```python
   data['Ratio_MA'] = data['Ratio'].rolling(window=20).mean()
   data['Ratio_STD'] = data['Ratio'].rolling(window=20).std()
   ```

3. Finally, we compute the Z-score as the number of standard deviations the current ratio is from its 20-day moving average:
   ```python
   data['Z_Score'] = (data['Ratio'] - data['Ratio_MA']) / data['Ratio_STD']
   ```

### Entry Conditions

Our strategy generates trading signals based on the Z-score crossing specific thresholds:

- When Z-score falls below negative threshold (-0.5, -1.0, etc.): This indicates MSTR is relatively undervalued compared to BTC. We enter a position going **long MSTR** and **short BTC**.

- When Z-score rises above positive threshold (0.5, 1.0, etc.): This indicates MSTR is relatively overvalued compared to BTC. We enter a position going **short MSTR** and **long BTC**.

```python
# Create position signals based on Z-score
df['Signal'] = 0
df.loc[df['Z_Score'] < -threshold, 'Signal'] = 1   # Long MSTR, Short BTC
df.loc[df['Z_Score'] > threshold, 'Signal'] = -1  # Short MSTR, Long BTC

# Apply signal with one-day delay to avoid lookahead bias
df['Position'] = df['Signal'].shift(1)
```

The strategy uses a one-day delay between signal generation and position execution to avoid lookahead bias, ensuring our backtest accurately reflects real-world trading constraints.

### Exit Conditions

Positions are exited when the Z-score reverts toward the mean, specifically:

- A long MSTR/short BTC position is exited when the Z-score rises back above -threshold
- A short MSTR/long BTC position is exited when the Z-score falls back below threshold

This mean-reversion approach is implemented by setting the position to zero when the Z-score returns to the range between the negative and positive thresholds:

```python
# Track trade entries and exits
df['Entry'] = df['Position'] != df['Position'].shift(1)
df['Exit'] = df['Position'].shift(1) != 0
df.loc[df['Entry'] & df['Exit'], 'Exit'] = False  # If both entry and exit, it's an entry
```

### Threshold Selection

The choice of Z-score threshold represents a trade-off between trading frequency and signal quality:

- **Lower thresholds** (e.g., 0.5): More frequent trades but potentially weaker signals
- **Higher thresholds** (e.g., 2.5): Fewer trades but stronger statistical divergence signals

Our backtest analyzes multiple thresholds (0.5, 1.0, 1.5, 2.0, 2.5) to identify the optimal balance. As shown in the performance metrics, the Z-score threshold of 2.5 provides the best risk-adjusted returns as measured by the Sharpe ratio.

### Trade Execution Logic

When a trade is initiated, equal dollar amounts are allocated to both legs of the pairs trade (long and short). The position sizes are kept constant throughout the trade duration until an exit signal is generated:

```python
# Calculate position values (assume equal dollar amounts in both legs)
df['MSTR_Position'] = df['Position'] * 1  # +1 for long, -1 for short
df['BTC_Position'] = -df['Position'] * 1  # Opposite of MSTR position
```

This market-neutral approach allows the strategy to potentially profit regardless of the overall market direction, focusing instead on the relative performance between MSTR and BTC.

## Backtest Results

The performance of our pairs trading strategy with different Z-score thresholds compared to buy-and-hold strategies:

```{python}
#| echo: false
#| warning: false
#| message: false

# Display the performance dataframe
display_df
```

### Best Strategy Analysis

```{python}
#| echo: false
#| warning: false
#| message: false

# Create a summary of the best strategies
best_strategies = pd.DataFrame([
    {'Strategy Type': 'Best Pairs Strategy', 'Strategy': best_pairs_strategy, 'Sharpe Ratio': best_pairs_sharpe},
    {'Strategy Type': 'Best Overall Strategy', 'Strategy': best_overall_strategy, 'Sharpe Ratio': best_overall_sharpe}
])

# Format the Sharpe ratio for display
best_strategies['Sharpe Ratio'] = best_strategies['Sharpe Ratio'].map('{:.2f}'.format)

# Display the best strategies
best_strategies
```

### Strategy Returns Visualization

The cumulative returns of all strategies:

```{python}
#| echo: false
#| warning: false

# Create DataFrame for cumulative return comparison
cum_returns_data_all = pd.DataFrame()

# Add pairs trading strategies
for threshold in thresholds:
    strategy = f'Pairs_Z{threshold}'
    cum_returns_data_all[strategy] = backtest_results[strategy]['Data']['Cumulative_Return']

# Add buy-and-hold strategies
cum_returns_data_all['Hold_MSTR'] = backtest_results['Hold_MSTR']['Cumulative']
cum_returns_data_all['Hold_BTC'] = backtest_results['Hold_BTC']['Cumulative']

# Reset index for plotting
cum_returns_data_all = cum_returns_data_all.reset_index()
cum_returns_data_all = cum_returns_data_all.rename(columns={'index': 'date'})

# Create interactive cumulative return plot
fig = px.line(
    cum_returns_data_all,
    x='date',
    y=cum_returns_data_all.columns[1:],
    title='Cumulative Returns of All Strategies',
    labels={
        'value': 'Cumulative Return (Initial Investment = 1)',
        'variable': 'Strategy'
    }
)

fig.update_layout(
    xaxis=dict(
        rangeslider=dict(visible=True),
        type="date"
    ),
    yaxis_title="Cumulative Return (Initial Investment = 1)",
    legend_title="Strategy",
    height=550,
    hovermode="x unified"
)

fig.show()
```

### Risk-Return Profile

```{python}
#| echo: false
#| warning: false

# Create risk-return table from actual backtest results
risk_return_table = performance_df[['Annual Return', 'Annual Volatility', 'Sharpe Ratio']].copy()

# Format for display
for col in ['Annual Return', 'Annual Volatility']:
    risk_return_table[col] = risk_return_table[col].map('{:.2%}'.format)
risk_return_table['Sharpe Ratio'] = risk_return_table['Sharpe Ratio'].map('{:.2f}'.format)

# Display as table
risk_return_table
```

### Drawdown Analysis

```{python}
#| echo: false
#| warning: false

# Get the best pairs strategy based on Sharpe ratio
best_strategy = best_pairs_strategy

# Calculate drawdown for best pairs strategy
pairs_drawdown = backtest_results[best_strategy]['Data']['Drawdown']

# Calculate drawdowns for buy and hold strategies
mstr_returns = backtest_results['Hold_MSTR']['Returns']
btc_returns = backtest_results['Hold_BTC']['Returns']

mstr_cum_returns = backtest_results['Hold_MSTR']['Cumulative']
btc_cum_returns = backtest_results['Hold_BTC']['Cumulative']

# Calculate drawdown series for both assets
mstr_running_max = mstr_cum_returns.cummax()
mstr_drawdown = (mstr_cum_returns / mstr_running_max - 1) * 100

btc_running_max = btc_cum_returns.cummax()
btc_drawdown = (btc_cum_returns / btc_running_max - 1) * 100

# Create DataFrame for plotting
drawdown_data = pd.DataFrame({
    'Date': pairs_drawdown.index,
    best_strategy: pairs_drawdown,
    'Hold_MSTR': mstr_drawdown,
    'Hold_BTC': btc_drawdown
})

# Reset index for plotting
drawdown_data = drawdown_data.reset_index(drop=True)

# Create drawdown chart
fig = px.line(drawdown_data, x='Date', y=[best_strategy, 'Hold_MSTR', 'Hold_BTC'],
             title='Drawdown Comparison',
             labels={'value': 'Drawdown (%)', 'variable': 'Strategy'},
             color_discrete_map={
                 best_strategy: 'green',
                 'Hold_MSTR': 'blue',
                 'Hold_BTC': 'red'
             })

# Add rangeslider for interactive zooming
fig.update_layout(
    xaxis=dict(
        rangeslider=dict(visible=True),
        type="date"
    ),
    yaxis_title="Drawdown (%)",
    legend_title="Strategy",
    height=500,
    hovermode="x unified"
)

# Add zero line
fig.add_hline(y=0, line_dash="solid", line_color="black", opacity=0.3)

fig.show()
```

## Trading Analysis

### Trade Performance by Z-Score Threshold

```{python}
#| echo: false
#| warning: false

# Format trade metrics for display
trade_metrics_df_display = trade_metrics_df.copy()
trade_metrics_df_display['Win Rate'] = trade_metrics_df_display['Win Rate'].map('{:.2%}'.format)
trade_metrics_df_display['Avg Return'] = trade_metrics_df_display['Avg Return'].map('{:.2%}'.format)
trade_metrics_df_display['Avg Duration'] = trade_metrics_df_display['Avg Duration'].map('{:.1f} days'.format)

# Display table
trade_metrics_df_display
```

### Position Analysis Over Time

```{python}
#| echo: false
#| warning: false

# Get position and trade data for best pairs strategy
best_strategy = best_pairs_strategy
threshold = float(best_strategy.split('Z')[1])  # Extract threshold from strategy name

# Access the actual trades data instead of all position days
trades = backtest_results[best_strategy]['Trades']
position_data = backtest_results[best_strategy]['Data']

# Create scatter plot with positions
fig = go.Figure()

# Plot Z-Score
fig.add_trace(
    go.Scatter(
        x=position_data.index,
        y=position_data['Z_Score'],
        mode='lines',
        name='Z-Score',
        line=dict(color='purple')
    )
)

# Add threshold lines
fig.add_hline(y=threshold, line_dash="dash", line_color="red", annotation_text=f"Upper Threshold ({threshold})")
fig.add_hline(y=-threshold, line_dash="dash", line_color="red", annotation_text=f"Lower Threshold (-{threshold})")
fig.add_hline(y=0, line_dash="solid", line_color="black", opacity=0.3)

# Plot trade entries - using the actual trades data
for i, trade in enumerate(trades):
    entry_date = trade['Entry_Date']
    entry_zscore = trade['Entry_Z_Score']
    position_type = trade['Entry_Type']

    marker_color = 'green' if position_type == 'Long MSTR/Short BTC' else 'red'
    marker_symbol = 'triangle-up' if position_type == 'Long MSTR/Short BTC' else 'triangle-down'

    fig.add_trace(
        go.Scatter(
            x=[entry_date],
            y=[entry_zscore],
            mode='markers',
            name=position_type + ' Entry',
            marker=dict(color=marker_color, size=10, symbol=marker_symbol),
            text=f"Trade {i+1}: {position_type}<br>Date: {entry_date.strftime('%Y-%m-%d')}<br>Z-Score: {entry_zscore:.2f}",
            hoverinfo='text',
            showlegend=(i == 0 or (i > 0 and trades[i-1]['Entry_Type'] != position_type))  # Only show in legend once for each type
        )
    )

    # Add exit points if available
    if 'Exit_Date' in trade and 'Exit_Z_Score' in trade:
        exit_date = trade['Exit_Date']
        exit_zscore = trade['Exit_Z_Score']

        fig.add_trace(
            go.Scatter(
                x=[exit_date],
                y=[exit_zscore],
                mode='markers',
                name='Trade Exit',
                marker=dict(color='black', size=8, symbol='x'),
                text=f"Trade {i+1} Exit<br>Date: {exit_date.strftime('%Y-%m-%d')}<br>Z-Score: {exit_zscore:.2f}<br>Return: {trade['Total_Return']:.2%}",
                hoverinfo='text',
                showlegend=(i == 0)  # Only show in legend for first occurrence
            )
        )

# Add annotation with trade count
fig.add_annotation(
    x=0.02,
    y=0.98,
    xref="paper",
    yref="paper",
    text=f"Total Trades: {len(trades)}",
    showarrow=False,
    font=dict(size=14, color="black"),
    align="left",
    bgcolor="white",
    bordercolor="black",
    borderwidth=1
)

# Layout setup
fig.update_layout(
    title=f"Z-Score and Trading Positions (Threshold = {threshold})",
    xaxis_title="Date",
    yaxis_title="Z-Score",
    hovermode="closest",
    height=500
)

fig.show()
```

### Sharpe Ratio Comparison

```{python}
#| echo: false
#| warning: false

# Extract Sharpe ratios for each strategy
sharpe_ratios = {strategy: performance_df.loc[strategy, 'Sharpe Ratio']
                for strategy in performance_df.index}

# Create bar chart of Sharpe ratios
fig = px.bar(
    x=list(sharpe_ratios.keys()),
    y=list(sharpe_ratios.values()),
    title='Sharpe Ratio Comparison Across Strategies',
    labels={'x': 'Strategy', 'y': 'Sharpe Ratio'},
    color=list(sharpe_ratios.keys()),
    color_discrete_map={
        'Hold_MSTR': 'blue',
        'Hold_BTC': 'red',
        'Pairs_Z0.5': 'lightgreen',
        'Pairs_Z1.0': 'green',
        'Pairs_Z1.5': 'darkgreen',
        'Pairs_Z2.0': 'darkblue',
        'Pairs_Z2.5': 'purple'
    }
)

# Add a line for zero Sharpe ratio
fig.add_hline(y=0, line_dash="dash", line_color="gray")

# Layout setup
fig.update_layout(
    xaxis_title="Strategy",
    yaxis_title="Sharpe Ratio",
    height=400
)

fig.show()
```

### Trade Win Rate vs Z-Score Threshold

```{python}
#| echo: false
#| warning: false

# Prepare data for win rate comparison
win_rates = []
for threshold in thresholds:
    strategy = f'Pairs_Z{threshold}'
    if 'Win Rate' in trade_metrics.get(strategy, {}):
        win_rate = trade_metrics[strategy]['Win Rate']
        win_rates.append({'Threshold': threshold, 'Win Rate': win_rate})
    else:
        # If win rate isn't available, calculate it from trades
        trades = backtest_results[strategy]['Trades']
        if trades:
            winning_trades = sum(1 for trade in trades if trade['Total_Return'] > 0)
            win_rate = winning_trades / len(trades)
            win_rates.append({'Threshold': threshold, 'Win Rate': win_rate})
        else:
            win_rates.append({'Threshold': threshold, 'Win Rate': 0})

win_rates_df = pd.DataFrame(win_rates)

# Create bar chart
fig = px.bar(
    win_rates_df,
    x='Threshold',
    y='Win Rate',
    title='Trade Win Rate by Z-Score Threshold',
    labels={'Threshold': 'Z-Score Threshold', 'Win Rate': 'Win Rate'},
    color='Threshold',
    color_continuous_scale='Viridis'
)

fig.update_layout(
    xaxis_title="Z-Score Threshold",
    yaxis_title="Win Rate",
    yaxis_tickformat='.0%',
    height=400
)

fig.show()
```

## Thoughts

This pairs trading strategy exploiting the MSTR-BTC relationship provides a market-neutral approach that can complement traditional long-only cryptocurrency and equity strategies. Based on our real market data analysis, the optimal configuration uses a Z-score threshold of 2.5, which provides the best Sharpe ratio among pairs strategies at 0.51.

While our backtest shows that simply holding MSTR would have yielded higher absolute returns with a Sharpe ratio of 2.89, the pairs trading approach demonstrates significantly better risk characteristics:

1. **Lower Maximum Drawdown** for pairs trading vs. holding MSTR
2. **Lower Volatility** for pairs trading vs. holding MSTR

## Potential Improvements

The pairs trading strategy could be enhanced through:

1. **Alternative Distribution Fitting**: The current approach assumes normal distribution of the ratio. We could improve signal generation by fitting alternative distributions (Student's t, skewed t, or mixture models) that better capture the fat-tailed nature of financial data.

2. **Dynamic Thresholds**: Instead of fixed Z-score thresholds, implementing adaptive thresholds based on market volatility regimes could improve performance.

3. **Machine Learning Enhancement**: Incorporating additional features beyond just the price ratio (such as volume, volatility, and sentiment indicators) into a machine learning model could better predict mean reversion points.

4. **Multi-Asset Extension**: Expanding beyond the MSTR-BTC pair to include other assets could create a more diversified statistical arbitrage portfolio.
